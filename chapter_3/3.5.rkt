; 3.50

(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons-stream
        (apply proc (map stream-car argstreams))
        (apply stream-map
               (cons proc 
                     (map stream-cdr 
                          argstreams))))))

; 3.51

; Interpreter will print the entire stream out (0-10), and then (stream-ref 5) would
; return 5, (stream-ref 7) would return 7

; 3.52

(define sum 0)
; At this point, sum is 0
(define (accum x)
  (set! sum (+ x sum))
  sum)
; sum still 0
(define seq 
  (stream-map 
   accum 
   (stream-enumerate-interval 1 20)))
; sum is now 1. The first item in the stream gets called with the accum function, but the
; rest are sitting in wait, not yet evaluated.
(define y (stream-filter even? seq))
; Since the first item (1) will not pass the predicate test, we will end up evaluating the
; second item (which will be 3 - the item (2) + the current value of sum), which will also
; be set as the new value of sum.

; Given that 3 is also not even, we will evaluate the next item - (which will be 3 + current
; value of sum (3), so 6 (and sum is also updated to this). Evaluation stops since we found
; a passing predicate
(define z 
  (stream-filter 
   (lambda (x) 
     (= (remainder x 5) 0)) seq))
; The first item in the sequence to be divisible by 5 is 10 (the fourth item), so sum will
; now increase to 10
(stream-ref y 7)
; This will take the 8th even number in the triangle number sequence (should be 136)
(display-stream z)
; By using stream-for-each, we'll end up evaluating the rest of the items. Since the final
; value of all the items summed is 210, this should be the value of sum. display-stream
; itself will print out all the triangle numbers divisible by 5, so (10, 15, 45, 55, 105,
; 120, 190, 210)

; 3.53

(define s (cons-stream 1 (add-stream s s)))
; The above will produce the same stream as:
(define double (cons-stream 1 (scale-stream double 2)))

; 3.54

(define factorials
  (cons-stream 1 (mul-streams factorials (stream-cdr integers))))

; 3.55

(define (partial-sums stream)
  (cons-stream (stream-car stream) (add-streams (stream-cdr stream) (partial-sums stream))))

; If we took the integers example, you would end up with:
; (cons-stream 1 (add-streams (2, 3, ...) .
; ^                                       |
; |---------------------------------------|
; This will result in:
; - First item 1
; - Next item 2 + first item of stream (1) = 3
; - Next item 3 + second item of stream (3, as above) = 6

; 3.56

(define S (cons-stream 1 (merge (scale-stream S 2)
                                (merge (scale-stream S 3)) (scale-stream S 5))))

; 3.57

(define fibs 
  (cons-stream 
   0 (cons-stream
      1 (add-streams 
         (stream-cdr fibs) fibs))))

; Assumes we're accessing using (stream-ref fibs n)

; Zero indexed element is immediately evaluated (0)

; Element at index 1 is effectively (lambda () 1), if we ignore `delay` and `memo-proc`,
; which wrap the function.

; When we get to the element at index 2, that will be adding the first element and
; the second, so (+ 0 1) (one addition performed)

; When we get to element at index 3, we'll re-perform the previous addition of (+ 0 1) to
; get element at index 2. When we then want to evaluate the element at index 3, we'll grab
; the element at index 1 (1 - no addition required), and then reevaluate element at index
; 2 (+ 0 1), adding those together (+ 1 1). This results in 3 additions.

; For element at index 4, we'll first perform the previous steps to get to index 3, and
; then when evaluating index 4, we'll re-perform the previous steps, finally being able
; to evaluate (+ 1 2). 7 additions

; For each index, here is total calculations / increase on previous / new calculations.
; Note that the number of new calculations is the fibonacci sequence:
; 0:  0
; 1:  0   / 0   / 0
; 2:  1   / 1   / 1
; 3:  3   / 2   / 1
; 4:  7   / 4   / 2
; 5:  14  / 7   / 3
; 6:  26  / 12  / 5
; 7:  46  / 20  / 8
; 8:  79  / 33  / 13
; 9:  133 / 54  / 21
; 10: 221 / 88  / 34
; 11: 364 / 143 / 55

; Note you can generate the stream of the growth of total calculations with the following,
; based on the fibonacci stream itself!:
(partial-sums (partial-sums fibs))

; 3.58

(expand 1 7 10)
; For the above, this will generate the repeating stream sequence of
; (1, 4, 2, 8, 5, 7, 1, 4, 2, 8, 5, 7, ...)
; 1/7 = 0.142857 (with the six number inifinitely repeated)

(expand 3 8 10)
; For the above, this will generate (3, 7, 5, 0, 0, 0, ...)

; Effectively returns the stream of decimals generated by the division of numerator and
; denominator. If the initial numerator was greater than the denominator, the results
; would be a little odd. Say if we had (expand 9 8 10), this would give us
; (11, 2, 5, 0, 0, 0, ...)

; 3.59

; Part 1:
; -------
; First of all, define the reciprocal function:
(define (reciprocal x) (/ 1 x))
; And then define the harmonic series (which generates 1, 1/2, 1/3, 1/4, etc.)
(define harmonic-series
  (stream-map reciprocal integers))

; In order to integrate the series and generate the stream of coefficients, we can then
; multiply the input stream by the harmonic series:
(define (integrate-series stream)
  (mul-streams stream harmonic-series))

; Part 2:
; -------
(define cosine-series 
  (cons-stream 1 (scale-stream (integrate-series sine-series) -1)))

(define sine-series
  (cons-stream 0 (integrate-series cosine-series)))

; 3.60

(define (mul-series s1 s2)
  (cons-stream (* (stream-car s1) (stream-car s2))
               (add-streams (scale-stream (stream-cdr s2) (stream-car s1))
                            (mul-series (stream-cdr s1) s2))))

; 3.61
; Had to look this one up!
(define (invert-unit-series series)
  (cons-stream 1 (scale-stream (mul-series (stream-cdr series)
                                           (invert-unit-series series))
                               -1)))

; 3.62

(define (div-series s1 s2)
  (if (= (stream-car s2) 0)
      (error "Cannot divide by zero!")
      (mul-series s1 (invert-unit-series s2))))

(define tangent-series
  (div-series sine-series cosine-series))

; 3.63

; Without using the memoization technique, the entire stream would be recalculated
; from the start for every consequent term. The original version prevents this by
; memoizing in two different places - the call to stream-map within guesses, AND
; within the stream-map function itself. If we follow this through, you'll find
; that, for calling (stream-ref (sqrt-stream x) 10), we access guesses 9 times,
; as well as call the function for each term following, resulting in 19
(stream-map
  (lambda (guess)
    (sqrt-improve guess x))
  guesses)

; The simpler implementation would not differ in efficiency without memo-proc being
; implemented. Every term would be recalculated every time it was accessed

; 3.64

(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))

(define (stream-limit stream tolerance)
  (define (iter previous remaining)
    (let ((current (stream-car remaining)))
      (if (or (null? previous)
              (> (abs (- previous current))
                 tolerance))
          (iter current (stream-cdr remaining))
          current)))
  (iter nil stream))

; 3.65

(define (ln-summands n)
  (cons-stream
    (/ 1.0 n)
    (stream-map - (ln-summands (+ n 1)))))

(define ln-stream
  (partial-sums (ln-summands 1)))

; Just the stream itself converges extremely slowly (after 100 elements it still has
; not managed two decimal places of accuracy.

; Using Euler transformation, it's accurate to 3 decimal places after 8 elements, 4
; decimal places after 14 elements, but for the 5th decimal place it takes about
; 35 elements.

; Using the accelerated sequence, it becomes extremely accurate within 10 elements.
; Note that if we try to make further guesses, we end up with a nan (not a number)
; issue, as the divisor in the euler transform equation becomes so small that we
; run out of accuracy and it becomes 0.0

; 3.66

; Comments about the stream:
; - The second of the pair is never less than the first
; - The second of the pair increases much more rapidly than the first

; For a pair x, y, where y > x, the number of preceding items can be worked
; out with: 2^x * (y - x + 0.5) - 2

; For the pair where x = y, that can be worked out with 2^x - 2

; 3.67

(define (pairs s t)
  (cons-stream
    (list (stream-car s) (stream-car t))
    (interleave
      (interleave
        (stream-map (lambda (x)
                      (list (stream-car s) x))
                    (stream-cdr t))
        (stream-map (lambda (x)
                      (list x (stream-car t)))
                    (stream-cdr s)))
      (pairs (stream-cdr s) (stream-cdr t)))))

; 3.68 

; The function loops infinitely without being able to generate the stream!

; 3.69

; Note this assumes we're using the old version of pairs, that generated (i, j) where i <= j
(define (triples s t u)
  (cons-stream
   (list (stream-car s) (stream-car t) (stream-car u))
   (interleave
    (stream-map (lambda (pair)
                  (cons (stream-car s) pair)) 
                (pairs t (stream-cdr u)))
    (triples (stream-cdr s) (stream-cdr t) (stream-cdr u)))))

; To generate pythagorean triples:

(define (pythagorean-triples s t u)
  (stream-filter
   (lambda (triple)
     (= (+ (square (car triple))
           (square (cadr triple)))
        (square (caddr triple))))
   (triples s t u)))

; 3.70

; Note that the original merge skipped items where they had the same value. Since we don't
; necessarily know what constitutes sameness, we can't make the same call here, unless we
; provide a function to check for equality. This could be achieved using equal? to compare
; a pair in a list, but not all streams are necessarily guaranteed to contain lists. In the
; case that the weights are equal, we insert the item from the first stream first.
(define (merge-weighted s1 s2 weight)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
          (let ((s1car (stream-car s1))
                (s2car (stream-car s2))
                (s1-car-weight (weight (stream-car s1)))
                (s2-car-weight (weight (stream-car s2))))
            (cond ((<= s1-car-weight s2-car-weight)
                   (cons-stream 
                     s1car 
                     (merge-weighted (stream-cdr s1)
                                     s2
                                     weight)))
                  (else
                    (cons-stream 
                      s2car 
                      (merge-weighted s1
                                      (stream-cdr s2)
                                      weight))))))))

(define (weighted-pairs a b weight)
  (cons-stream
    (list (stream-car a) (stream-car b))
    (merge-weighted
      (stream-map (lambda (x)
                    (list (stream-car a) x))
                  (stream-cdr b))
      (weighted-pairs (stream-cdr a) (stream-cdr b) weight)
      weight)))

; Part 1:
(define integer-pairs-ordered-by-sum
  (weighted-pairs integers
                  integers
                  (lambda (x) (+ (car x) (cadr x)))))

; Part 2:
; Generating the list of numbers not divisible by 2, 3, or 5
(define integers-not-divisible-by-2-3-or-5
  (stream-filter
   (lambda (x) (not (or (= (remainder x 2) 0)
                        (= (remainder x 3) 0)
                        (= (remainder x 5) 0))))
   integers))

; Ordering their pair combinations by the sum 2i + 3j + 5ij:

(define special-stream
  (weighted-pairs
    integers-not-divisible-by-2-3-or-5
    integers-not-divisible-by-2-3-or-5
    (lambda (pair)
      (let ((i (car pair))
            (j (cadr pair)))
        (+ (* i 2)
           (* j 3)
           (* 5 i j))))))

; 3.71

; Utility functions to sum the cubes of each pair:
(define (cube x) (* x x x))
(define (sum-cubes pair)
  (+ (cube (car pair))
     (cube (cadr pair))))

; Utility to generate stream of pairs ordered by the sum of their cubes:
(define pairs-ordered-by-sum-of-cubes
  (weighted-pairs integers integers sum-cubes))

; The function to genereate n number of ramanujan numbers:
(define (ramanujan-numbers-stream number-to-find)
  (define (iter prev-sum-of-cubes stream number-to-find)
    (let ((sum-of-cubes (sum-cubes (stream-car stream))))
      (cond ((zero? number-to-find) nil)
            ((eq? sum-of-cubes prev-sum-of-cubes)
             (cons-stream sum-of-cubes
                          (iter sum-of-cubes (stream-cdr stream) (- number-to-find 1))))
            (else
              (iter sum-of-cubes (stream-cdr stream) number-to-find)))))
  (iter nil pairs-ordered-by-sum-of-cubes number-to-find))

; Using a slightly amended version of the function, we can output the ramanujan numbers,
; in combination with the pairs that produced that number:
'((1729 (1 12) (9 10))
  (4104 (2 16) (9 15))
  (13832 (2 24) (18 20))
  (20683 (10 27) (19 24))
  (32832 (4 32) (18 30))
  (39312 (2 34) (15 33)))

; 3.72

; Utility to sum the squares of a given pair of numbers:
(define (sum-squares pair)
  (+ (square (car pair))
     (square (cadr pair))))

; The stream of pairs ordered by the sum of their squares:
(define pairs-ordered-by-sum-of-squares
  (weighted-pairs integers integers sum-squares))

; Function to find the first n numbers that can be written as the sum of two squares
; in three different ways:
(define (blobby-numbers-stream number-to-find)
  (define (iter previous-previous previous stream number-to-find)
    (let ((sum-of-squares (sum-squares (stream-car stream))))
      (cond ((zero? number-to-find) nil)
            ((and (eq? sum-of-squares previous-previous)
                  (eq? sum-of-squares previous))
             (cons-stream sum-of-squares
                          (iter previous
                                sum-of-squares
                                (stream-cdr stream)
                                (- number-to-find 1))))
            (else
              (iter previous
                    sum-of-squares
                    (stream-cdr stream)
                    number-to-find)))))
  (iter nil nil pairs-ordered-by-sum-of-squares number-to-find))

; If we also want to print out the pairs that generate these numbers, we can create
; the following constructors and selectors:

(define (make-weight-and-pair weight pair)
  (list weight pair))

(define (get-weight weight-and-pair)
  (car weight-and-pair))

(define (get-pair weight-and-pair)
  (cadr weight-and-pair))

; Then, in order to keep track of the pairs whose squares sum to the same value, we can
; 
(define (blobby-numbers-stream number-to-find)
  (define empty-weight-and-pair (make-weight-and-pair nil '(nil nil)))
  (define (iter previous-previous previous stream number-to-find)
    (let ((sum-of-squares (sum-squares (stream-car stream))))
      (cond ((zero? number-to-find) nil)
            ((and (eq? sum-of-squares (get-weight previous-previous))
                  (eq? sum-of-squares (get-weight previous)))
             (cons-stream (list sum-of-squares
                                (list (stream-car stream) (get-pair previous-previous) (get-pair previous)))
                          (iter previous
                                (make-weight-and-pair sum-of-squares (stream-car stream))
                                (stream-cdr stream)
                                (- number-to-find 1))))
            (else
             (iter previous
                   (make-weight-and-pair sum-of-squares (stream-car stream))
                   (stream-cdr stream)
                   number-to-find)))))
  (iter empty-weight-and-pair
        empty-weight-and-pair
        pairs-ordered-by-sum-of-squares
        number-to-find))

; Note that we could use this second procedure and just provide the weight as the first
; argument to cons-stream if we didn't want to provide both the weight AND the pairs whose
; squares summed to that weight.

; 3.73

(define (RC R C dt)
  (lambda (i v0)
    (add-streams (integral (scale-stream i (/ 1 C)) v0 dt)
                 (scale-stream i R))))

; 3.74

(define zero-crossings
  (stream-map sign-change-detector 
              sense-data 
              (stream-cdr sense-data)))

; 3.75

; The bug is that when calculating each average, we take the average of the next input
; from the stream with the previous average that we calculated, instead of the two raw
; inputs. Because we want to pass the smoothed values to the sign change detector, we
; will need to pass both the raw previous value, AND the averaged previous value

(define (make-zero-crossings 
          input-stream last-value last-average)
  (let ((avpt 
          (/ (+ (stream-car input-stream) 
                last-value)
             2)))
    (cons-stream 
      (sign-change-detector avpt last-average)
      (make-zero-crossings 
        (stream-cdr input-stream) (stream-car input-stream) avpt))))

; 3.76

; Smoothing function that takes a stream and returns the stream of the averages of
; each two successive inputs:
(define (smooth sense-data)
  (define (average a b)
    (/ (+ a b) 2))
  (stream-map average
              sense-data
              (stream-cdr sense-data)))

; We can then implement zero crossings quite easily using the previously simplified
; version, but using the smoothing function:
(define (zero-crossings sense-data)
  (let ((smoothed (smooth sense-data)))
    (stream-map sign-change-detector
                smoothed
                (cons-stream 0 smoothed))))

; 3.77

(define (integral-b
          delayed-integrand initial-value dt)
  (cons-stream 
    initial-value
    (let ((integrand (force delayed-integrand)))
      (if (stream-null? integrand)
          the-empty-stream
          (integral-b
            (delay (stream-cdr integrand))
            (+ (* dt (stream-car integrand))
               initial-value)
            dt)))))

; 3.78

; Note that due to the scheme implementation, I have to delay `ddy`, and then force
; it within the delay in the definition of `dy`. This is because otherwise, I get
; an error trying to generate the first value of the `ddy` stream, as `dy` and `y`
; are still undefined:
(define (solve-2nd a b dt y0 dy0)
  (define y (integral (delay dy) y0 dt))
  (define dy (integral (delay (force ddy)) dy0 dt))
  (define ddy (delay (add-streams (scale-stream dy a)
                                  (scale-stream y b))))
  y)

; 3.79

; We can generalise solve-2nd by extracting the function taking dy and y as arguments:
(define (f a b)
  (lambda (dy y)
    (add-streams (scale-stream dy a)
                 (scale-stream y b))))

; Then removing the corresponding definitions from solve-2nd:
(define (solve-2nd f dt y0 dy0)
  (define y (integral (delay dy) y0 dt))
  (define dy (integral (delay (force ddy)) dy0 dt))
  (define ddy (delay (f dy y)))
  y)

; In order to generate e:
(define dt 0.0001)
(define y0 1)
(define dy0 1)
(stream-ref (solve-2nd (f 1 0) dt y0 dy0)
            10000) ; => 2.7181459268252266

; 3.80

(define (RLC R L C dt)
  (lambda (vC0 iL0)
    (define vC (integral (delay (force dvC)) vC0 dt))
    (define iL (integral (delay (force diL)) iL0 dt))
    (define dvC (delay (scale-stream iL (/ -1 C))))
    (define diL (delay (add-streams (scale-stream iL (/ (- R) L))
                                    (scale-stream vC (/ 1 L)))))
    (cons vC iL)))

(define example-circuit (RLC 1 1 0.2 0.1))
(define example-circuit-streams (example-circuit 10 0))
; (car example-circuit-streams) gives the following first 10 items for the vC stream:
; (10 10 9.5 8.55 7.220000000000001 5.5955 3.77245 1.8519299999999999 -0.0651605000000004 -1.8831384500000004)
; (cdr example-circuit-streams) gives the following first ten items for the iL stream:
; (0 1.0 1.9 2.66 3.249 3.6461 3.84104 3.834181 3.6359559 3.2658442599999997)

; 3.81

(define (random-numbers requests)
  (define numbers
    (cons-stream random-init
                 (stream-map (lambda (n request)
                               (cond ((eq? request 'generate) (rand-update n))
                                     ((eq? request 'reset) random-init)
                                     (else (error "UNKNOWN REQUEST: " request))))
                             numbers
                             requests)))
  numbers)

; 3.82

; An empty stream to map over and generate the trials stream:
(define null-stream (cons-stream nil null-stream))

(define (estimate-integral P x1 x2 y1 y2)
  (define trials-stream
    (stream-map (lambda (x)
                  (P (random-in-range (float x1) (float x2))
                     (random-in-range (float y1) (float y2))))
                null-stream))
  (let ((rectangle-area (* (abs (- x1 x2))
                           (abs (- y1 y2)))))
    (stream-map (lambda (n)
                  (* rectangle-area n))
                (monte-carlo trials-stream 0 0))))
